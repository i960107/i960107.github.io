---
title: 백엔드 프리온보딩 1주차 역량 향상 강의 - AWS 인프라 관련 요소딩. 이것이 JAVA다 - 멀티 스레드, 입출력
tags:
- 백엔드
- 22년12월
- JAVA
author: 수현
--
# 백엔드 프리온보딩
## 커리큘럼

- 1주차: 인프라 관련 요소들. 직접 서버 제공하지 않지만 서버 운영에 도움 ex) 로드 밸런서
    - API Gateway, 들3, ELB, CloudFront, Secret Manager, 스냅샷
- 2주차: 컴퓨팅 파워(서버).
    - EC2, Elastic Beanstalk, ECS, Lambda(Serverless)
- 3주차: 메시지 큐. 공부할때는 트래픽이 많지 않아 생각해보지 않지만, 현업에서는 많이 쓰임.
    - SQS, MSK, Kinesis
- 4주차: 데이터 베이스
    - RDS, DynamoDB, ElasticCache

## 1주차

- **왜 많은 회사들이 AWS 인프라를 이용하는지에 대해 논의합니다.**
- 인프라 관련 요소들 : **AWS API Gateway, AWS S3, AWS ELB, AWS CloudFront, AWS Secret Manager, 스냅샷**

### AWS가 무엇일까

- On-premise 과 Cloud Computing의 차이: On-premise란 기업의 서버를 자체적으로 보유한 전산실 서버에 직접 설치해 운영하는 방식
- Cloud Computing: 클라우드 컴퓨팅은 **인터넷을 통하여** 데이터를 저장하거나 데이터베이스, 서버, 네트워킹, 소프트웨어와 같은 도구, 어플리케이션 등 다양한 서비스를 제공하는 방식.

### Cloud Computing을 쓰는 이점

- Kafka: 메세지 서버. 배달의 민족은 모든 서버의 리퀘스트를 메세지로 받음. 평균 50만건, 최대 140만건 메세지 유입. 만약 on-premise로 사용한다면 최대 140만건의 메세지를 처리할 수 있도록 리소스 구축 필요.

###  인프라 관련 AWS 서비스(1) - AWS VPC( vertual private cloud)

- 가상 **네트워크** 서비스로 **퍼블릭** 네트워크와 **프라이빗** 네트워크를 분리하고 모니터링 할 수 있게 해주는 서비스 → 서비스에 **울타리**를 칠 수 있는 기능.
- 필요한 이유: 꼭 필요한 곳에만 인터넷과 연결시켜야지 보안이 좋음.  예를 들어, 사용자 민감 정보가 담긴 유저 DB가 있는데 인터넷에 연결되어 있으면, 사용자 정보 유출 가능성. **DB는** 서버와만 연결되어 있고 인터넷에서 연결하지 않음. Ddos 공격을 해도 서버는 죽되, DB는 안전하게 유지될 수 있다.
- 인터넷에서 인스턴스 하나하나를 볼 수 있느게 아니라, VPC 안 인터넷 게이트웨이(대문과 같은 존재)를 거쳐야한다. 인터넷 게이트웨이 → AWS API 게이트웨이 서비스를 제공.
- DB는 프라이빗 서브넷, 통신이 필요한 서번의 경우 퍼블리 서브넷에 위치 시킴.

###  인프라 관련 AWS 서비스(2) -  API Gateway.

- API Gateway는 인터넷 게이트웨이의 역할 +  트래픽 관리, CORS지원,  api 버전관리, 인증 맨 앞단에서 필요한 많은 것들을 처리해줌
- 인증을 서버에서 세션,  JWT 토큰으로 인증이 국룰.
- 하지만, 서비스가 여러개로 분산되어 있어서 앞단에서 통일된 정책으로 서버 전에 인증 처리하고 싶다 혹은 Lambda서버의 경우(함수를 실행시킨다). → API Gateway에 인증 관련 로직 추가가능.

###  인프라 관련 AWS 서비스(3) - ELB

- Elastic Load Balancing
- 다수의 컴퓨팅 리소스를 부하 분산시켜주는 아주 중요한 서비스.
- 보통 서버를 여러대 띄움. 요청이 왔을때 임의의(인스턴스 사용량) 인스턴스에 전달해줌.
- 총 3가지 종류의 Balancer(Application Load Balancer, Gateway Load Balancer, Network Load Balancer)가 있음. 보통 ALB를 사용. TCP/UDP보다는 Http/Https를 사용하는 경우가 많음.

###  인프라 관련 AWS 서비스(4) - S3

- simple storage service
- 이미지, 동영상, 오디오 파일, json파일 등 정적파일들을 용이하게 관리하도록 돕는 스토리지 서비스.
- 크기 화질을 줄인 썸네일을 사용해서 서버 부하를  줄이는데 사용하는데 S3에 업로드되면 자동으로 썸네일을 생성하도록 하기도 함.

###  인프라 관련 AWS 서비스(5) - CloudFront

- s3 앞단의 캐시 서버. CDN 서비스를 제공함
- S3 + CloudFront를 사용하면 속도는 높이고 ,가격은 내리며, 서버 부하는 줄임
- S3는 비쌈. 요청이 올때마다 매번 S3에 접근하면 많은 돈을 지불해야 함.
- S3는 캐싱을 하고 싶은 버킷을 설정할 수 있음.
- 예를 들어, 코드너리 사이트에 기업들 로고는 자주 바뀌지 않음. → S3의 특정 버켓을  CloudFront에 캐싱할 수 있음. 로고 개발자 검사시 static.codnary.co.kr에 위치.
- 만약에 캐시 데이터와 실제 데이터가 다른 경우 → 클라우드 프론트의 무효화 사용. 이미 캐싱되어 있는 것들을 다 날리고, 새로 S3에서 캐싱해라.

# 이것이 JAVA다 - 멀티스레드

### 멀티 스레드 정의 및 활용 주의할점

- **정의**:  프로세스 내 하나의 **코드 실행 흐름.**
- 멀티 프로세스가 어플리케이션 단위의 멀티 태스킹이라면 멀티 쓰레드는 어플리케이션 내부에서의 멀티 태스킹.
- 자바 어플리케이션은 **메인스레드**가 main() 메소드를 실행하면서 시작되고, 메인 메소드 외의 스레드들을 **작업 스레드**가 됨.
- **활용**
    - 대용량 데이터의 처리 시간을 줄이기 위해 데이터를 분할해서 병렬로 처리.
    - UI를 가지고 있는 어플리케이션에서 네트워크 통신을 하기 위해 사용.
    - 다수 클라이언트의 요청을 처리하는 서버를 개발할때 사용.
    - 여러 개의 작업을 동시에 처리할때 사용
        - 미디어 플레이어가 동영상 재생과 음악 재생
        - 메신저에서 채팅하면서 사진 전송.
    - **주의할 점**
        - 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수 있음. →**예외 처리** 중요
        - 실행중인 스레드가 하나라도 있다면, 프로세스는 종료되지 않는다. → 프로세스 종료시 스레드가 종료되게 하려면 데몬 스레드 사용
        - 공유 객체를 사용할 경우 동기화 필요

### 작업 스레드 생성 방법

- 방법1) Thread 클래스 객체를 생성. Runnable 객체를 매개변수로 넘김
    - Runnable은 인터페이스로 구현객체 필요.
    - Runnable은 추상 함수가 하나인 함수적 인터페이스라서 람다식 사용 가능.
    - Runnable은 실행해야하는 코드가 있는 객체로 스레드가 시작(스레드 객체의 start()호출)되면 Runnable의 run()함수가 실행됨.
    
    ```java
    //생성된 Runnable 구현 객체 사용
    Runnable target = new BeepTask();
    Thread thread = new Thread(Runnable target); 
    public class BeepTask implements Runnable{
    }
    //익명 구현 객체 사용
    Thread thread = new Thread(new Runnable(){
    })
    //람다식 사용
    Thread thread = new Thread(()->{
    }) 
    ```
    
- 방법2) Thread 하위 클래스로부터 생성:  Thread 클래스를 상속한 후 run 메소드를 재정의.
    
    ```java
    // 하위 클래스 선언 후 객체 생성
    public class WorkerThread extends Thread{
    	@Override
    	public void run(){
    	}
    }
    Thread thread = new WorkerThread();
    
    // Thread 익명 자식 객체 생성
    Thread thread = new Thread(){
    	public void run(){
    }
    }
    ```
    
- Thread 클래스 대강의 모양.
    
    ```java
    public class Thread{
    String name;
    boolean Daemon;
    int priority;
    Runnable target;
    ThreadGroup group;
    
    public Thread(Runnable target){
    	this.target = target
    }
    public void run(){
    	if(target != null){
    		target.run()
    }
    }
    public static sleep(){
    }
    }
    ```
    
- 스레드 객체가 생성된 후 start()메소드가 호출되면, 메인 스레드와 작업스레드의 코드 흐름이 동시에 진행됨

### 스레드와 우선순위

- **동시성**은 멀티 작업을 위해 **하나의 코어**에서 멀티 스레드가 **번갈아가며** 실행하는 성질.
- **병렬성**은 멀티 작업을 위해 **멀티 코어**에서 개별 스레드를 **동시에** 실행하는 성질.
- 스레드의 개수가 코어의 수보다 많을 경우, 스레드를 **어떤 순서에 의해 동시성으로 실행**할 것인가 **스케쥴링** 해야함.
    - 우선순위 방식: 개발자가 제어 가능
    - 라운드 로빈 방식: 시간 할당량이 기계에 의해 정해짐.

### 동기화 메소드와 동기화 블록

- 동기화 필요한 이유: 스레드들이 객체를 공유해서 작업하는 경우 중간에 다른 스레드에 의해 값이 변경될 수 있다. 스레드가 사용중인 객체를 다른 스레드가 변경할 수 없도록 객체에 잠금을 걸기 위해서 동기화 메소드나 동기화 블록을 사용한다.
- 메소드 전체 내용 잠금 동기화 메소드, 일부 내용 잠금 동기화 블록을 사용한다. 임계 영역 안에서 사용된 모든 객체들 함께 잠김. ex) 변수
- 동기화 메소드와 동기화 블록이 여러개 있을 경우, 스레드가 이들 중 하나를 실행할때, 다른 스레드는 **해당 메소드**는 물론이고 **다른 동기화 메소드 및 블록도 실행할 수 없다**. 일반 메소드만 실행 가능하다.

### 스레드 상태 및 스레드 상태 제어 방법

- 상태( Thread 열거 상수)
    - NEW : 객체는 생성됐는데 start()호출되지 않음
    - RUNNABLE: 실행 대기 상태.
    - WAITING: wait()에 의해 다른 스레드가 통지할때까지 기다리는 상태
    - TIME_WAITING: sleep()에 의해 일시 정지 상태
    - BLOCKED: 사용하고자 하는 객체의 **락**이 풀릴때까지 기다리는 상태(동기화 혹은 블로킹에 의해 막힘)
    - TERMINATED: 실행을 마친 상태
    - 실행은 상태 없음
- **스레드 상태 제어**
    - 주어진 시간 동안 일시정지 : sleep(). 시간 지나면 자동으로 실행 대기 상태
    - 다른 스레드에게 실행 양보: yield(). 실행대기 상태가 됨.
    - 다른 스레드의 종료를 기다림: join(). ThreadA 안에서 ThreadB.join()하면 ThreadB가 종료될때까지 기다렸다가 실행.waiting상태
    - 스레드간 교대 작업: wait(), notify(), notifyall()
    - 스레드를 종료: interrup(). 스레드가 일시정지 상태에 있을때 InterruptedException발생시킴. 혹은 stop플래그 이용 가능.

### 데몬 스레드

- **보조적인 역할**을 수행하는 스레드로. 주 스레드가 종료될때 **강제로 종료**됨
- 주 스레드가 데몬 스레드의 setDaemon()호출
- 예시: 워드프로세서의 자동 저장, 미디어 플레이어 동영상 및 음악 재생, 가비지 컬렉터

### 스레드 그룹

- 관련된 스레드를 묶어서 관리. **일괄적으로 처**리할 수 있음
- 스레드그룹을 생성자 매개변수로 넘겨줌.
- 예시: 동시에 interrupt()

### 스레드 풀

- 스레드 개수가 폭증하면 어플리케이션 성능이 저하됨. 스레드의 개수를 제한해두고 작업큐에 들어오는 작업들을 하나씩 스레드가 맡아서 처리.
- 스레드수: 초기 스레드수/ 코어 스레드수(최소)/최대 스레드 수
- 작업 생성: Runnable또는 Callable 클래스 사용
- 작업 처리 요청: execute()혹은 submit()사용. execute()는 예외 발생시 스레드 삭제. submit()은 스레드 재사용. 스레드 생성 오버헤더를 줄이기 위해 submit()사용하는 것이 좋음.
- 작업 완료 통보
    - 블로킹 방식: Future객체를 즉시 리턴받고 결과를 사용하기 위해 get()호출하면 결과 리턴될때까지 블로킹 됨. 스레드 BLOCKED상태.
    - 콜백 방식: 스레드가 작업을 완료하면 특정 메소드를 자동 실행. Runnable 구현시 CompletionHandler사용하기.
    - CompletionHandler 비동기 통신에서 콜백 객체를 만들때 사용됨.