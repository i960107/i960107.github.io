---
title: 알고리즘 - 해시테이블
tags:
- 23년 1월
- CS
- 알고리즘
author: 수현
---

# 알고리즘
## 해시테이블
+ 해시테이블(또는 해시맵)은 **키를 값에 매핑**하여 저장하는 <u>자료구조</u>를 말한다. 가장 큰 특징은 데이터의 양에 상관없이 검색, 추가, 삭제의 시간복잡도가 O(1)로 **빠르다**는 것이다. 
+ **해시 함수**를 활용해 임의 크기 데이터를 고정 크기 값으로 변환해주는 함수로(키 -> 해시 값),  해시 테이블을 인덱싱하기 위해서(색인을 남기다. 찾아보기 쉽도록 일정한 순서로 나열) 해시 함수를 사용하는 것을 해싱이라고 한다. 
    + 대표적인 해싱 알고리즘: 정수형 해싱 기법 - 나눗셈 방식(modulo-division method)
+ 해싱의 **활용**: 최적의 검색이 필요한 곳, 심볼 테이블(컴파일러와 같은 언어변환기에서 사용되는 데이터 구조로 주소-심볼 이름 -타입을 연결), Checksum(통신에서 값의 무결성을 검사하는 방법), 손실 압축, 무작위화함수, 암호 등과도 관련이 깊다.
+ **성능 좋은 해시 함수들의 특징**:
    1. 해시 함수 값 충돌의 최소화
    2. 쉽고 빠른 연산
    3. 해시 테이블 전체에 값이 균일하게 분포
    4. 사용할 키의 모든 정보를 이용하여 해싱
    5. 해시 테이블 사용 효율이 높을 것
+ 비둘기집 원리: n개의 아이템을 m개 컨테이너에 넣을때, n>m이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리. 적어도 1번 이상 충돌이 일어남.
+ **로드 팩터(Load Factor)**: 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것이다. 로드 팩터 비율에 따라 해시 함수를 재작성 혹은 해시 테이블의 크기를 조정. 로드 팩터가 증가할수록 해시 테이블의 성능은 점점 감소함. 로드 팩터가 일정 이상 증가하면 버킷 수를 늘린다.
+ 충돌: 다른 키의 해시 값이 같아서 해시테이블의 같은 버킷에 저장될때.
    + 충돌 해결 방법: 개별 체이닝(연결리스트 혹은 레드-블랙 트리로 연결), 오픈 어드레싱(충돌이 일어나면 테이블 공간 내에서 빈 공간을 찾아서 저장).
    + 개별 체이닝 방식은 연결리스트를 만들기 위해 추가 메모리 할당이 필요하고, 추가 메모리 할당은 상대적으로 느린 작업이라는 단점이 있다. 오픈 어드레싱 방식은 클러스터링 현상으로 전체적인 해싱 효율이 떨어질 수 있고, 버킷 사이즈보다 많은 데이터를 저장하기 위해서는 리해싱이 필요하다는 단점이 있다.
+ **언어별** 해시 테이블 **구현** 방식:
    + **루비나, 파이썬**과 같은 모던 언어들은 **오픈 어드레싱** 방식을 택해 성능을 높이는 대신, **로드 팩터를 작게 잡아** 성능 저하 문제를 해결한다. 오픈 어드레싱의 한 방식인 선형 탐사 방식은 일반적으로 체이닝에 비해 성능이(조회당 평균 캐시 성공률) 더 좋다. 그러나 버킷의 80%이상 차면 급격한 성능 저하가 일어난다.
    + **java**의 Map 자료형에는 HashMap, LinkedHashMap, TreeMap등이 있다. HashMap의 충돌을 균형 트리 체이닝 방식으로 해결한다. LinkedHashMap은 HashMap을 상속받으며, 버킷 사이에 순서가 있다는 차이점이 있다(insertion order, access order). HashMap은 O(N) LinkedHashMap은 O(LogN)복잡도를 가진다.map의 key는 어떤 타입이든 가능하지만, 커스텀 객체인 경우 비교가 가능하도록 equals() 와 hashcode()를 구현해주어야한다. TreeMap은 HashMap, LinkedHashMap과 달리 배열에 버킷을 저장하지 앟는다. 해시테이블 사용하지 않는다. 균형트리인 red-black트리에 저장하므로, 조회, 삽입, 삭제 O(LogN) 복잡도를 가짐
+ 맵과 해시맵의 차이
> MAP자료형의 경우 각 값을 참조하는데 걸리는 시간이 O(LogN)이라고 되어있는데,
MAP자료형이 파이썬의 dictionary 자료형을 일컫는 것이 맞나요?
제가 알기로 dict의 경우 내부적으로 해시로 구현되어있어 각 값을 참조하는데 O(1)복잡도라고 알고있는데 왜 O(LogN)이 되는지 궁금합니다.
  + 맵과 해시맵의 차이: 맵은 해시테이블을 이용하지 않고도 구현가능함(ex. TreeMap). HashMap - O(1) ,LinkedHashMap - O(1), TreeMap - O(LogN)
  + 빠르게 조회 검색하고, 순회 하지않고, 노드들 간의 순서 필요 없을때는 HashMap. 순서 필요하고 순회 자주 일어나는 경우 LinkedHashMap. 정렬 필요한 경우 TreeMap 하지만 LinkedHashMap보다 성능 나쁨.
+ [질문] LinkedHashMap - AccessOrder는 어떻게 조회할때마
다 내부적으로 정렬하나? 어떻게 LRU 캐시에 활용하나? 왜 TreeMap이 아닌 LinkedHashMap을 사용하나?
    + [참고 링크 - A Guid To LinkedHashMap](https://www.baeldung.com/java-linked-hashmap)
