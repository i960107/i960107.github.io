---
title: 그래프 DFS/BFS, DP - 7 Segment display
tags:
- algorithm
- 22년10월
author: 수현
---
# 그래프

- 그래프의 포인트는 dfs냐 bfs냐, 인접 행렬이냐 인접리스트냐 임!

### 그래프의 최장 경로

- 두 정점 사이를 이동할때 사용할 수 있는 가장 많은 간선의 수 → 출발 노드의 depth를 1이라고 한다면 depth -1
- 왜 visited[current] 를 다시 False로 인접 노드들에 대한 재귀호출이 끝나고 현재 경로가 아닌 다른 경로를 탐색할때 현재 노드는 방문하지 않은 것임 . 그래프의 탐색1에서는 그렇게 하지 않은 이유 → 인덱스 작은 노드부터 탐색하는 경로 하나만 탐색하기 때문.
    - [ ]  만약 모든 경로를 탐색해야한다고 했을때 재귀에서는 어떻게 처리할 수 있지? 각 경로마다 visited배열 새로 생성?
- 최장거리를 계산할때는 dfs나 bfs나 모든 경로를 살펴봐야하는 것은 같음. 하지만 bfs는 한번에 여러 경로를 살펴야해서 queue의 길이가 매우 늘어나게 복잡해짐. dfs가 더 나은 방법
- MAXIMUM VIRUS가 되는 만큼 모든 경우의 수를 조사하는 것보다 target number를 발견하면 멈추는게 더 빠름. 만약 목표 개체수가 1인데 10000마리까지 조사하는 것 불필요한 연산 너무 많음

### 그래프의 최단 경로

- bfs로 계산하면서 dest 뿐만아니라 만나는 모든 노드들의 최단 거리를 기록해둘 수 있음.
    - distance[i] := origin … i까지의 최단 경로의 간선의 수

### 미로 탈출하기

- 현재 좌표의 상, 하, 좌, 우 좌표를 bfs_queue에 넣어줄때 “-”일때만 삽입. “E”일때 제외됨. 그게 아니라 “#”이어서 갈 수 없는 곳만 제외해주기.
- 입력받은 문자열을 리스트로 변환하고 싶을때 input().split()하면 리스트 원소 하나가 됨. list(input())해야 함
- `# 가장 자리에 dummy 헤드를 추가해서 원소들이 1 ~ R, 1 ~ C의 값을 가지도록, 가장 자리는 passale = False임.`

### 토마토

- 어떻게 모든 토마토가 익었는지 검사하지?
- 토마토가 없는 곳은 어떻게 처리하지. visited True로 바꾸어줘야 하나 visited True로 바꾸어 줬떠니 정사각형 이 -1일때 안쪽에 -1 은 visited 되지 않음!
    - 내가 한 방법
    - 코드
- 토마토 상태를 나타내는 상수로 관리하는 것도 좋음

### 단지 번호 붙이기

- 영역의 크기를 계산할때는 bfs? dfs? 영역이 너무 큰 경우 메모리 낭비 심해지므로 한번에 한 경로만 관리하는 dfs가 더 적절. 전체 경우를 탐색하는 것과 비슷
- 상하좌우로 인접한 집으로부터 연결된 집의 수를 계산하여 가산한다. → dfs

## 동적계획법

### 7 segment display

- knapsack과 달리 상태공간을 1차원으로 설정하는 이유
- str(”-1”)[0] ⇒ “-1”
- return 0 return EMPTY
- 뒷자리에서부터 혹은 앞자리에서부터 혹은 둘다 고려?
- self.f(total_cost - self.items[0].cost)하면 000인 경우도 제외되나?