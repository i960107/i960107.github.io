---
title: 하드웨어 구성요소/ 오브젝트 - 소프트웨어 품질 기준/구름 챌린지 복습
tags:
- 알고리즘
- 객체지향
- CS
- 22년12월
author: 수현
---
# 1일 1로그 - 하드웨어

- 하드웨어는 컴퓨팅에서 형체가 있고 조작할 수 있는 기기가 장치를 말한다.
- 컴퓨팅 장치는 초기에는 주로 천문 현상이나 행성 또는 별의 위치를 예측하는데 특화된 형태. → 방직에 사용된 천공카드 방식 자카르 직기  등 기계 부품에 의존하는 컴퓨팅 → 전자 부품으로 된 컴퓨팅
    - 애니악
    - 애드삭 : 명령어와 데이터를 한 군데 저장
    - 트랜지스터와 직접회로를 사용한 현대식 컴퓨터
- 이 장에서 배우는 내용
    - 하드웨어의 구성요소
    - 컴퓨터가 어떻게 비트, 바이트, 이진수로 정보를 표현하는지
    - 컴퓨터가 어떻게 계산을 수행하는지. 즉, 비트와 바이트를 어떻게 처리하는지

### 컴퓨터의 논리와 구조

- pc, 맥, 크롬북, 스마트폰, 태블릿 pc 등 다양한 컴퓨팅 장치들은 물리적으로는 다르지만 논리적으로 내부 작동 원리를 근본적으로 같다.

### 프로세서 속도와 심장 박동 수

- 컴퓨터의 논리적 아키텍처 → 폰 노이만 아키텍처
    - 프로세서: cpu
    - 메모리: ram
    - 저장장치: hdd/ssd
    - 입출력장치
    
    ⇒ **프로세스**는 **산술 연산과 제어 기능**을 제공하고, **주 기억장치와 보조 기억장치**는 **기억**과 **저장**을 담당하며, **입출력장치**는 **운영자와 상호작용** 한다.
    

# 오브젝트
### 객체 중심 설계 - 협력, 책임, 역할

- 객체 지향 설계의 핵심은 역할, 책임, 협력이다.
- 협력은 어플리케이션 기능을 구현하기 위해 메세지를 주고받는 객체들 사이의 상호작용이다.
- 책임은 객체가 다른 객체와  협력하기 위해 수행하는 행동이고, 역할은 대체가능한 책임의 집합이다.

### 데이터 중심 설계

- 포함해야 하는 데이터가 무엇인지를 가장 먼저 생각
- 자신이 포함하고 있는 데이터를 조작하는데 필요한 오퍼레이션을 관리
- 한계점
    1. 데이터 중심의 설계는 접근자(accessor, getter)와 수정자(modifier, setter)를 통해 내부 구현을 인터페이스의 일부로 만들기 때문에 캡슐화를 위반한다. →추측에 의한 설계 전략, 최대한 다양한 상황에 사용되도록 미리 접근자, 수정자를 만들어둔다
    2. 제어 객체가 다수의 객체에 강하게 결합된다.

### RDD

- Resposibility Driven Development
- CRC 카드를 작성 → 객체 지향 구현
- 협력이 행동을 결정, 행동이 상태를 결정
- 행동과 상태가 책임이 됨
- 과정
    1. 시스테 책임을 파악한다
    2. 더 작은 책임으로 분할한다(클라이언트 입장에서 보내는 메세지 고려)
    3. 분할한 책임을 수행할 수 있는 역할 또는 개체를 찾아 책임을 할당한다
    4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
    5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다
    
    → 산출물 CRC
    

### 추상 클래스와 인터페이스

- 추상클래스는 책임의 일부를 구현
- 인터페이스는 일체의 구현 X, 책임의 집합만을 나열

### SRP

- 단일 책임 원칙 = 단일 변경의 이유 원칙
- 클래스의 응집도를 높이기 위한 원칙
- 단 하나의 변경의 이유만을 가진다
- 여러 이유로 변경되는 코드가 하나의 모듈안에 공존하지 않는다

### 소프트웨어 품질 기준 - 캡슐화, 응집도와 결합도

- 변경이 발생할때, 모듈 전체가 변경되다면 응집도가 높다.
- 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도(ripple effect - 파급 효과)를 말한다.
    
    → 필드의 타입 변경이 필요할 경우에 미치는 파급효과를 고려해보면 결합도를 알 수 있다.

# 구름 챌린지 복습
### 폭탄 구현하기

- 방법 1) 매 위치마다 상, 하, 좌, 우 인덱스 범위 검사하기
- 방법 2) 위치에 따라서 영향줄 수 있는 영역의 크기가 달라짐. 위치를 카테고리화하기
- ⇒ 둘다 O(N) (N은 폭탄의 갯수) 복잡도를 가지지만 방법 2가 연산의 회수를 줄일 수 있음

### 철자 분리 집합

- 그룹별 정보(철자, 개수)를 기록하고 싶다면 spell, count라는 변수를 사용해서 이전 인덱스의 값을 기억해야 한다.
- 하지만 집합의 개수만 구하고 싶다면, 그룹이 분리되는 곳만 알면 되므로, 인덱스를 이용해서 바로 이전 값과 비교만 하면 된다. 값 기억할 필요 없음.

### 경로의 개수

- 큰 수 개념:  파이썬에서는 별 다른 문제 없이 해결됨. C -lang 계열에서는 표현하기 어려우 수로 BigInteger 구조체 선언이 필요.
- 파이썬3에서의 정수형은 int 타입 뿐이다.
- 파이썬3에는 오버플로우가 없다?  C에서는 데이터 타입에 따라서 컴퓨터가 할당할바이트 수가 정해져있기 때문에, 항상 오버플로우가 발생할 위험이 있다. 그런데 파이썬3의 정수형은 arbitrary precision을 사용해서 오버플로우가 발생하지 않는다.
- 미리 메모리에 할당되어진 숫자들: python에서는 실제 사용하지 않더라도 -5와 256사이의 정수들을 integer object 배열에 미리 저장해 둔 후, reference를 참조한다.

[[기초 파이썬] 파이썬 3에는 오버플로우가 없다?](https://ahracho.github.io/posts/python/2017-05-09-python-integer-overflow/)

### 동명이인

- str 클래스의 **contains**(): key in str을 반환
- 문자열 매칭 알고리즘
    - 브루트포스의 경우 시간 복잡도는 O(nk) n과 k는 각 문자열의 길이.
    - KMP 알고리즘
    - 라빈 -카프 알고리즘
- [https://naroforme.tistory.com/entry/알고리즘-문자열-매칭-알고리즘-KMP-Knuth-Morris-Pratt-Pattern-matching](https://naroforme.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A7%A4%EC%B9%AD-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-KMP-Knuth-Morris-Pratt-Pattern-matching)

### ✔️최장 맨해튼 거리