---
title: 사칙연산, 등굣길, 양궁대회, 인접 리스트를 이용한 그래프의 BFS/DFS
tags:
- algorithm
- 22년10월
author: 수현
---
### 사칙연산

- 테스트케이스는 통과했는데 제출후 실패할때 왜 실패인지 모르겠으면 테스트케이스를 다시 손으로 풀어보기!
- 2차원 배열의 각 원소가 배열일때 list comprehension에서 *로 배열복사하면 안됨
    - [[a,b] * n for _ in range(n)] →한행에 2 *n개의 원소가 n행이 됨
    - [[[a,b]] * n for _ in range(n)]이 되어야
    - [[a, b] for _ in range(n) for _ in range(n)] → len(n) = n^2.
- range dp

### 양궁대회

- range dp? n my m dp? cost를 고려해야 하는 dp. knapsack problem과 비슷
- last_item_index 와 total_cost를 x,y축으로 2차원의 상태공간 만들기
- 최대 점수는 range dp로 계산해서 얻을 수 있음. 최대 점수를 얻기 위해서 맞춰야하는 과녁 수는?
- 현재 과녁을 맞추고 남은 걸로 앞에 과녁들을 맞출 수 없다면
- 얻을 수 있는 최대 점수만 고려하면 안되고 포기한 점수는 어피치가 얻게 되므로 그것도 고려해야함.
- dp가 아니라 bfs

### 등굣길

- 첫째열 첫째행 처리하는 방법 : 1) dummy행 열을 만든다, 2)첫째행, 첫째열만 따로 처리해준다 → 1 -based index로 나타내고 있으므로 방법1)이 더 나음
- 갈수 없는 길 vs 가는 방법이 없는 길 물덩이면 0이 아니라 -1로 관리
- 왜 계속 실패하는 거지?

## 그래프

- 인접 행렬방식과 인접리스트 방식의 시간 복잡도의 차이
- 모든 정점 뿐만 아니라 모든 경로를 전부 조회해야 한다면 DFS를 사용하기. BFS를 사용하면 탐색의 깊이가 점점 깊어질수록 큐에 저장하고 있어야할 경로의 정보가 기하급수적으로 늘어난다
- DFS를 사용하면 한번에 하나의 경로의 수만을 고려하면서 탐색을 수행하고, 현재 경로가 포함하는 노드 혹은 간선 정보를 관리하기 편하다
- 인접리스트는 노드의 추가 삭제가 빈번하게 발생하는 경우, 인접 행렬은 간선의 추가 삭제가 빈번하게 발생하는 경우 사용하기 좋음. 두 노드가 연결되었는지 확인하는 시간은 인접리스트가 오래 걸림. 한 노드에 연결된 모든 node들을 알아내는데 걸리는 시간은 인접 행렬이 오래 걸림.

### 그래프의 탐색2

- 간선 정보를 받아서 인접 리스트를 구성한 후 정렬해주어야함. 그래야 작은 노드부터 혹은 큰 노드부터 순서대로 탐색가능
- 중복된 간선 정보가 들어올 수도 있음
- dictionary 자료형의 typehint: 인접리스트의 경우 Dict[int, List[int]]