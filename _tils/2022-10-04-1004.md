---
title: 다이나믹프로그래밍 - path문제, 파스칼의 삼각형 문제
tags:
- algorithm
- 22년10월
author: 수현

---

{::options parse_block_html="true"/}
<div style = "text-align: justify">
# 구름 위클리 미션

### 경로의 개수

### 동명이인
- 포함된  → 중간에 들어갈 수도 있음 어떻게 표현하지? startswith 안됨
- 정규표현식?
- find 혹은 name in names 사용 가능. 단 find는 포함되어있을경우 시작 인덱스포함되어있지 않을경우 -1을 반환

### 최장 맨하튼 거리
- 어떻게 4개 정수를 2개씩 짝지어서 2개 좌표를 만들지 → 이후 해설강의 필요
- 총 12가지의 경우 가능
- 잘못 생각한 것 : 그룹화만 하면 된다고 생각. but x, y 순서 바뀌면 다른 좌표가 됨.

### 소수찾기

# 동적 계획법

- 불필요한 계산을 줄이고, 효율적으로 최적해를 찾아야만 풀이는 문제들.
- 부분구조의 해를 활용해서 더 큰 부분구조의 해를 찾고 최종적으로 최적 해를 찾아가는 문제들.
- 최적 부분 구조(최적 해결 방법은 부분 문제에 대한 최적 해결 방법으로 구성된다) + 중복된 하위 문제들

### [프로그래머스] N으로 표현

- 왜 틀릴까? 2개로 표현할 수 있는 모든 수 각각을 N과 사칙연산을 통해 만들어낸 수가 N3개로 표현할 수 있는 수 → {cnt : set()}으로 저장. 테스트 케이스 실패 왜?
- 내가 잘못 생각한 부분
    1. 4개를 사용해 구할 수 있는 수는 3개를 사용해 만들수 있는 수에 사칙연산을 수행한  결과이다?1개를 사용해 만들 수 있는 결과 +-*// 3개를 사용해 만들 수 있는 결과 뿐 아니라 2 개를 사용해 만들 수 있는 결과 +-*// 2개를 사용해 만들 수 있는 결과 를 포함함
    2. - 와 // 연산은 앞뒤 순서가 바뀌면 다른 결과가 나옴.
    3. 매 연산마다 결과가 number와 일치한다면 return하고 일치하지 않을 경우에만 set에 추가. 해시의 value가 set일때 매번 연산 결과가 number인지 확인하는 것 보다 s에 모든 값을 추가하고 난 후 number in s로 확인하는게 더 나음 O(1). 
    4. 55도 5를 두번 반복해서 만들수 있는 숫자임. 문제를 더 꼼꼼하게 읽고 테스트케이스를 살폈으면 더 빨리 발견했을것
    5. 555는 5 * 111로 계산했는데, 단지 5를 cnt만큼 반복하면 됨.

### [프로그래머스] 정수 삼각형

- 밑에서부터 올라갈 경우 가장 앞 열, 뒷 열 인덱스 체크 필요 없음!

### [프로그래머스] 등교길

- 주의사항 0열과 0행의 경우 한군데라고 0이면 그 이후 모두 경로 0 임. 초기화시 이전 원소의 값을 그대로 가지고 가는게 아니라, 이전 원소와 현재 원소 둘 중에 하나라도 0 이면 0이 되어야함. min(이전 원소, 현재 원소)

### [프로그래머스] 도둑질

- 여러번 반복해 푼 문제지만 답을 알아도 왜 그렇게 계산하는지 이해가 잘 안됨
- 집들이 순환이 아니라 선형으로 배열되어 있다면 dp를 각 집까지 모든 경우의 수 중 가장 큰 이익이 아니라 dp를 그 집을 터는 모든 경우에 최대 이익이라고 하면 dp[i] = max(dp[i-3], dp[i-2]) + money[i]로 계산해도 되지 않나?
    - 리트코드 house robber 문제로 검증. 가능함 단 return 값은 max(dp[-2], dp[-1])임
    - dp를 각 집 까지 모든 경우의 수 중(그 집을 털지 않는 경우도 포함) 가장 큰 이익이라고 하면 dp[i] = (dp[i-2] + nums[i], dp[i-1]) 이며, return dp[-1]이 됨.
    - 초기화 3개 원소 필요
    - dp 초기화시 기존 money 배열 길이 주의!  1인 경우 2인경우 다 따로 처리 필요

### [프로그래머스] 사칙연산

- 앞에서 -이면 뒤 사칙연산들도 부호 바뀌어야함.
- 잘못 생각한 점:
    - 앞에 한번이라도 - 나왔으면 다음 부호 뒤집어서 계산한 결과 추가해주어야 함? 아님 앞에서 부호 뒤집지 않았으면 즉 괄호 끝났으면 현재 부호도 뒤집을 수 없음
    - 

# vim tip

- 다음 소괄호 전까지 삭제하고 싶다 d**t**(
- 줄 맨 앞에 삽입 : I(insert)
- 줄 맨 뒤에 삽입 : A( append)